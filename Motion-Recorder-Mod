using System;
using spaar.ModLoader;
using UnityEngine;
using System.IO;
using System.Collections.Generic;

namespace Motion_Recorder_Mod
{
    public class MotionPainterMod : Mod
    {
        public override string Name { get { return "Motion_Recorder_Mod"; }} 
        public override string DisplayName { get { return "Motion Recorder Mod"; }}
        public override string BesiegeVersion { get { return "v0.25"; } }
        public override string Author { get { return "覅是"; }}
        public override Version Version { get { return new Version("1.2"); }} 
        public override bool CanBeUnloaded { get { return true; }}
        private GameObject temp = new GameObject();
        public override void OnLoad()
        {
            temp.name = "Motion Recorder Mod";
            temp.AddComponent<MotionPainterTemP>();
            temp.AddComponent<MotionWriter>();
            temp.AddComponent<MotionReader>();
            GameObject.DontDestroyOnLoad(temp);
        }

        public override void OnUnload()
        {
            GameObject.Destroy(temp.GetComponent<MotionPainterTemP>());
            GameObject.Destroy(temp.GetComponent<MotionWriter>());
            GameObject.Destroy(temp.GetComponent<MotionReader>());
            GameObject.Destroy(temp);
        }
        
        
    }

    public class MotionPainterTemP : MonoBehaviour
    {
        private string startPaint = "a";
        public Color StartColor = Color.blue;
        public Color EndColor = Color.white;
        public float Lerp = 0.5f;
        public float Width = 0.1f;
        private GameObject[] HaveThisConList;
        void Start()
        {
            Commands.RegisterCommand("ResetPaintKey", (args, notUses) =>
            {
                try
                {
                    startPaint = args[0];
                    return "Your paint key will be " + startPaint + "!";
                }
                catch { return "Reset paint key failed!\r\n Example: \r\n ResetPaintKey a"; }

            }, "Reset the key to activate painting.");//Key 
            Commands.RegisterCommand("TrailStartColor", (args, notUses) =>
            {
                try
                {
                    StartColor = new Color(float.Parse(args[0]), float.Parse(args[1]), float.Parse(args[2]));
                    return "Your paint color will be  " + StartColor;
                }
                catch { return "Reset color failed!\r\n Example: \r\n TrailStartColor  0 1 1"; }

            }, "Reset the start color of the trail.");//SC
            Commands.RegisterCommand("TrailEndColor", (args, notUses) =>
            {
                try
                {
                    EndColor = new Color(float.Parse(args[0]), float.Parse(args[1]), float.Parse(args[2]));
                    return "Your paint color will be  " + EndColor;
                }
                catch { return "Reset color failed!\r\n Example: \r\n TrailEndColor 1 0 1"; }

            }, "Reset the end color of the trail.");//EC
            Commands.RegisterCommand("TrailWidth", (args, notUses) =>
            {
                try
                {
                    Width = float.Parse(args[0]);
                    return "Your Width will be  " + Width;
                }
                catch { return "Reset Width failed!\r\n Example: \r\n TrailWidth 1.3"; }

            }, "Reset the Width of the trail.");//WD
            
        }
        void FixedUpdate()
        {
            if (Input.GetKey(KeyCode.F6)^Input.GetKey(startPaint))
            {
                RaycastHit hitt;
                if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hitt, float.PositiveInfinity))
                {
                    if (!hitt.transform.gameObject.GetComponent<MotionPainterScript>())
                    {
                    hitt.transform.gameObject.AddComponent<MotionPainterScript>();
                        //Debug.Log(hitt.transform.gameObject.GetComponent<ConfigurableJoint>().linearLimitSpring.spring + hitt.transform.gameObject.name + Physics.gravity);
                    }                    
                }
            }
        }
    }
    public class MotionPainterScript : MonoBehaviour
    {
        private int 顶点数目 = 1;
        void Start()
        {
            float width = GameObject.Find("Motion Recorder Mod").GetComponent<MotionPainterTemP>().Width;
            Color StartColor = GameObject.Find("Motion Recorder Mod").GetComponent<MotionPainterTemP>().StartColor;
            Color EndColor = GameObject.Find("Motion Recorder Mod").GetComponent<MotionPainterTemP>().EndColor;
            this.gameObject.AddComponent<LineRenderer>();
            this.gameObject.GetComponent<LineRenderer>().material = new Material(Shader.Find("Particles/Additive"));
            this.gameObject.GetComponent<LineRenderer>().SetWidth(width, width);
            this.gameObject.GetComponent<LineRenderer>().SetColors(StartColor,EndColor);
            this.gameObject.GetComponent<LineRenderer>().SetPosition(顶点数目 - 1, this.transform.position);
        }
        void FixedUpdate()
        {
            if (AddPiece.isSimulating)
            {
                顶点数目++;
                float width = GameObject.Find("Motion Recorder Mod").GetComponent<MotionPainterTemP>().Width;
                Color StartColor = GameObject.Find("Motion Recorder Mod").GetComponent<MotionPainterTemP>().StartColor;
                Color EndColor = GameObject.Find("Motion Recorder Mod").GetComponent<MotionPainterTemP>().EndColor;
                this.gameObject.GetComponent<LineRenderer>().SetVertexCount(顶点数目);
                this.gameObject.GetComponent<LineRenderer>().SetPosition(顶点数目 - 1, this.transform.position);
                this.gameObject.GetComponent<LineRenderer>().SetWidth(width, width);
                this.gameObject.GetComponent<LineRenderer>().SetColors(StartColor, EndColor);
            }
        }
    }
    public class MotionWriter:MonoBehaviour
    {
        private string TheFile = "";
        public int FrameCount = 0;
        public bool isRecording = false;
        public int BlockCount;
        private Queue<string> FramesRecord = new Queue<string>();
        private Queue<string> AllPoses = new Queue<string>();
        private Queue<string> AllRots = new Queue<string>();
        private Queue<string> AllBraceAPoses = new Queue<string>();
        private Queue<string> AllBraceBPoses = new Queue<string>();
        private Queue<string> AllBools = new Queue<string>();

        void Update()
        {
            if (!AddPiece.isSimulating)
            {
                if (isRecording)
                {
                    isRecording = false;
                    SaveTheMotionRecord();
                }
            }
            if (Input.GetKeyUp(KeyCode.F7))
            {
                isRecording = !isRecording;
                if(isRecording)
                { BlockCount = Machine.Active().SimulationMachine.childCount; }
                else { SaveTheMotionRecord(); }
            }
            
            
                if (isRecording)
                {
                    int DaLength = Machine.Active().SimulationMachine.childCount;
                    Vector3[] Pos = new Vector3[DaLength];
                    Quaternion[] Rot = new Quaternion[DaLength];
                    Vector3[] BraceAPos = new Vector3[DaLength];
                    Vector3[] BraceBPos = new Vector3[DaLength];
                    bool[] IsBraceThingy = new bool[DaLength];
                    int BlockCount = 0;
                    foreach (Transform block in Machine.Active().SimulationMachine.transform)
                    {
                        Pos[BlockCount] = block.position;
                        Rot[BlockCount] = block.rotation;
                        try
                        {
                            block.FindChild("BraceA").gameObject.name = "BraceA";
                            IsBraceThingy[BlockCount] = true;
                        }
                        catch
                        {
                            IsBraceThingy[BlockCount] = false;
                        }
                        if (IsBraceThingy[BlockCount])
                        {
                            BraceAPos[BlockCount] = block.Find("BraceA").transform.position;
                            BraceBPos[BlockCount] = block.Find("BraceB").transform.position;
                        }
                        else
                        {
                            BraceAPos[BlockCount] = Vector3.zero;
                            BraceBPos[BlockCount] = Vector3.zero;
                        }
                        ++BlockCount;
                    }
                AllPoses.Enqueue(Vector3sToString(Pos));
                AllRots.Enqueue(QuaternionToString(Rot));
                AllBools.Enqueue(BoolsToString(IsBraceThingy));
                AllBraceAPoses.Enqueue(Vector3sToString(BraceAPos));
                AllBraceBPoses.Enqueue(Vector3sToString(BraceBPos));
                        ++FrameCount;
                }
            
        }

        public string Vector3sToString(Vector3[] VCT3s)
        {
            string FinishedText = "";
            for (int i = 0; i < VCT3s.Length;++i)
            {
                if (i != 0)
                {
                    FinishedText += "|";
                }
                FinishedText += VCT3s[i].x + "," + VCT3s[i].y + "," + VCT3s[i].z;
            }
            return FinishedText;
        } 
        public string QuaternionToString(Quaternion[] QUTs)
        {
            string FinishedText = "";
            for (int i = 0; i < QUTs.Length; ++i)
            {
                if (i != 0)
                {
                    FinishedText += "|";
                }
                FinishedText += QUTs[i].w + "," + QUTs[i].x + "," + QUTs[i].y + "," + QUTs[i].z;
            }
            return FinishedText;
        }
        public string BoolsToString(bool[] Bs)
        {
            string FinishedText = "";
            for (int i = 0; i < Bs.Length; ++i)
            {
                if (i != 0)
                {
                    FinishedText += "|";
                }
                FinishedText += Bs[i].ToString();
            }
            return FinishedText;
        }
        void SaveTheMotionRecord()
        {
            for (int FMCT = 0; FMCT < FrameCount;++FMCT)
            {
                FramesRecord.Enqueue("Position#" + AllPoses.Dequeue() + "#Rotations#" + AllRots.Dequeue() + "#Braceful#" + AllBools.Dequeue() + "#Braceful Start Position#" + AllBraceAPoses.Dequeue() + "#Braceful End Positionr#" + AllBraceBPoses.Dequeue());
            }
            Debug.Log(FrameCount);
            for (int i = 0; i < FramesRecord.Count; ++i)
            {
                if (i != 0)
                {
                    TheFile += "%";
                }
                TheFile += FramesRecord.Dequeue().ToString(); 
            }
            File.WriteAllText(Application.dataPath + "/SavedMachines/LatestRecord-" + FrameCount + "-" + BlockCount + "-.txt", TheFile);
            TheFile = "";
            FramesRecord.Clear();
            FrameCount = 0;
            Debug.Log("Recorded!");
        }
    }
    public class MotionReader : MonoBehaviour
    {
        private string[] FramesRecord;
        private string TheFileName;
        public int FrameCount = -1;
        public int LoadedFrameCount = 0;
        public bool isReplaying = false;
        public bool isReplayingInSpecialMode = false;
        

        void Start()
        {
            Commands.RegisterCommand("RPP", (args, notUses) =>
            {
                    try
                    {
                    if (AddPiece.isSimulating)
                    {
                            TheFileName = args[0];
                            LoadedFrameCount = int.Parse(args[0].Split('-')[1].Trim());
                            FrameCount = 0;
                        if (int.Parse(args[0].Split('-')[2].Trim()) == Machine.Active().SimulationMachine.childCount) {
                            FramesRecord = ReadTheRecord();
                            isReplaying = true;
                            return "Replaying!";
                            }
                        else { return "Not Enough Blocks!" + Machine.Active().SimulationMachine.childCount; }
                        
                    }
                    else { return "The replay must be under simulation mode!"; }
                    }
                    catch { return "Reading File Failed! Please ensure that your file has the frame count and block count!"; }

            }, "Replay the record");//Replay
            Commands.RegisterCommand("RPS", (args, notUses) =>
            {
                try
                {
                    if (AddPiece.isSimulating)
                    {
                        TheFileName = args[0];
                        LoadedFrameCount = int.Parse(args[0].Split('-')[1].Trim());
                        FrameCount = 0;
                        if (int.Parse(args[0].Split('-')[2].Trim()) == Machine.Active().SimulationMachine.childCount)
                        {
                            FramesRecord = ReadTheRecord();
                            isReplayingInSpecialMode = true;
                            return "Replaying in Special Mode!";
                        }
                        else { return "Not Enough Blocks!" + Machine.Active().SimulationMachine.childCount; }

                    }
                    else { return "The replay must be under simulation mode!"; }
                }
                catch { return "Reading File Failed! Please ensure that your file has the frame count and block count!"; }

            }, "Replay the record in special mode. Use + and - to change the moment.");//Replay
        }
        void Update()
        {
            if (!AddPiece.isSimulating) { isReplaying = false; isReplayingInSpecialMode = false; }
            if (Input.GetKey(KeyCode.KeypadPlus) && isReplayingInSpecialMode) { ++FrameCount; }
            if (Input.GetKey(KeyCode.KeypadMinus) && isReplayingInSpecialMode) { --FrameCount; }
            try
            {
                if (FrameCount == FramesRecord.Length && FramesRecord.Length != 0 && !isReplayingInSpecialMode) { isReplaying = false; Debug.Log("Replay Done!"); }
            }
            catch { }
            if (FrameCount < 0) { FrameCount = 0; }

            if (isReplaying ^ isReplayingInSpecialMode)
            {
                if (FrameCount < FramesRecord.Length - 1)
                {
                    string[] thisFrame = FramesRecord[FrameCount].Split('#');
                    string[] Pos = thisFrame[1].Split('|');
                    string[] Rot = thisFrame[3].Split('|');
                    string[] IsBraceThingy = thisFrame[5].Split('|');
                    string[] BraceAPos = thisFrame[7].Split('|');
                    string[] BraceBPos = thisFrame[9].Split('|');

                    int NowBlock = 0;
                    foreach (Transform block in Machine.Active().SimulationMachine)
                    {
                        try
                        {
                            block.GetComponent<Rigidbody>().isKinematic = true;
                            block.position = StringToVector3(Pos[NowBlock]);
                            block.rotation = StringToQuaternion(Rot[NowBlock]);
                            if (StringToBool(IsBraceThingy[NowBlock]))
                            {
                                block.Find("BraceA").transform.position = StringToVector3(BraceAPos[NowBlock]);
                                block.Find("BraceB").transform.position = StringToVector3(BraceBPos[NowBlock]);
                            }
                        }
                        catch { }
                        ++NowBlock;
                    }
                    if (isReplaying)
                    {
                        ++FrameCount;
                    }
                }
                else
                {
                    Debug.Log("Da end has been reached (～￣▽￣)→))*￣▽￣*)o");
                    FrameCount = FramesRecord.Length - 2;
                }
            }
            else { FrameCount = 0; }

        }

        public Vector3 StringToVector3(String VCT3s)
        {
            Vector3 Vct3;
            string[] xyz = VCT3s.Split(',');
            Vct3 = new Vector3(float.Parse(xyz[0]), float.Parse(xyz[1]), float.Parse(xyz[2]));
            return Vct3;
        }
        public Quaternion StringToQuaternion(String QUTs)
        {
            Quaternion Qut;
            string[] wxyz = QUTs.Split((','));
            Qut = new Quaternion( float.Parse(wxyz[1]), float.Parse(wxyz[2]), float.Parse(wxyz[3]),float.Parse(wxyz[0]));
            return Qut;
        }
        public bool StringToBool(String Bs)
        {
            bool boolbool;
            boolbool = bool.Parse(Bs);
            return boolbool;
        }
        public string[] ReadTheRecord()
        {
            if (TheFileName != null)
            {
                return File.ReadAllText(Application.dataPath + "/SavedMachines/" + TheFileName).Split('%');
            }
            else
            {
                return File.ReadAllText(Application.dataPath + "/SavedMachines/LatestRecord.txt").Split('%');
            }
        }
    }
}
